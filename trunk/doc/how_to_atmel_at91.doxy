/* =============================================================================

   Copyright (c) 2009 Pieter Conradie <pieterconradie@users.berlios.de>
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.

============================================================================= */

/**
 * @page ARM_AT91_QUICK_START_GUIDE Atmel AT91SAM quick start guide
 * 
 * This is a quick start guide for the person who wants to switch to the 
 * Atmel AT91SAM series microcontroller and learns by example.
 * 
 * @par The following free software tools are needed:
 * - <a href="http://www.yagarto.de">YAGARTO GNU ARM toolchain 28.09.2008</a> : a suite of executable, open source software development tools for ARM microcontrollers hosted on the Windows platform. It includes the GNU GCC compiler for C and C++.
 * - <a href="http://winavr.sourceforge.net">WinAVR 20080610</a> : packaged with many native Win32 GNU programs and utilities including make and bash.
 * - <a href="http://openocd.berlios.de/web/">OpenOCD 0.1.0</a> : JTAG software to program and debug 32-bit microcontrollers.
 * - <a href="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4343">AT91 Library Software Package 1.5</a> : contains board and device specific files (C-Startup files, low level initialization, register description files), peripheral APIs, on-board components configuration files, USB Framework and utilities.
 * 
 * @par Reference documentation:
 * - <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100e/index.html">ARM Architecture Reference Manual ARM DDI 0100E</a> 
 * - <a href="http://www.atmel.com/dyn/products/product_card.asp?part_id=3524">Atmel AT91SAM7S256 datasheet</a>
 * - <a href="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3784">Atmel AT91SAM7S-EK evaluation kit documents</a>
 *
 * @par Other resources:
 * - <a href="http://www.atmel.com/dyn/products/app_notes.asp?family_id=605">Using Open Source Tools for AT91SAM7 Cross Development</a> : a guide for using open source tools such as Cygwin, GNU/GCC ARM Compiler, Eclipse IDE, Zylin CDT and OpenOCD for low-cost development of AT91SAM7 applications.
 * - <a href="http://www.state-machine.com/arm/">Building Bare-Metal ARM Systems with GNU</a> : detailed article on how to use the GNU toolchain for ARM to build real-life embedded systems based on ARM microcontrollers.
 *
 * @par Sections:
 * - @ref ARM_AT91_INTRODUCTION 
 * - @ref ARM_AT91_CRT 
 * - @ref ARM_AT91_LD
 * - @ref ARM_AT91_MAKEFILE 
 * - @ref ARM_AT91_LSS 
 * - @ref ARM_AT91_NEWLIB 
 * - @ref ARM_AT91_JTAG 
 * 
 * @par Tutorials:
 * @ref ARM_AT91_TUTORIALS
 * - @ref ARM_AT91_TUT01_ASM_BASIC 
 * - @ref ARM_AT91_TUT02_ASM_ADVANCED 
 * - @ref ARM_AT91_TUT03_C_BOARD_INIT 
 *  
 * @par Examples: 
 * @ref ARM_AT91_EXAMPLES 
 * - @ref ARM_AT91_LED_BLINK
 *  
 * <hr>
 * @section ARM_AT91_INTRODUCTION Introduction 
 *  
 * With increased flexiblity comes increased complexity. The learning curve for 
 * 32-bit ARM microcontrollers is much steeper than for example 8-bit Atmel AVR 
 * microcontrollers. To become really proficient one needs to learn how to use
 * several new tools and syntaxes:
 * - <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/">Using the GNU Compiler Collection (GCC)</a> 
 * - <a href="http://sourceware.org/binutils/docs-2.18/as/index.html">Using gas, the GNU assembler (GNU Binutils 2.18 documentation)</a> 
 * - <a href="http://sourceware.org/binutils/docs-2.18/ld/index.html">GNU ld (GNU Binutils) 2.18 documentation (the GNU linker)</a> 
 * - <a href="http://www.gnu.org/software/make/manual/make.html">GNU Make</a> 
 * - <a href="http://sourceware.org/newlib/">Newlib - a C library intended for use on embedded systems</a>
 * - <a href="http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html">Debugging with GDB, The GNU Source-Level Debugger</a> 
 *  
 * It is advised that if your time equals money and you would rather spend your 
 * time developing and debugging new firmware applications then you should turn 
 * to a cost effective toolchain with board support packages from 
 * <a href="http://www.rowley.co.uk">Rowley Crossworks</a> 
 * and buy a CrossConnect JTAG debugger.
 *  
 * <hr>
 * @section ARM_AT91_CRT C Run time initialisation (arm_crt0.S) 
 *  
 * Assembler start up code is provided that: 
 * - Routes the exception vectors to handlers 
 * - Copies the exception vector code to internal SRAM in preparation for remapping
 * - Copies specific code to internal SRAM (with attribute __attribute__ ((section (".text.sram")))) 
 * - Calls a low level board initialisation routine written in C 
 * - Initialises the DATA section (C variables with initial values) 
 * - Clears the BSS section (C variables that should be set to zero) 
 * - Initialises a stack for each processor mode (FIQ, IRQ, UND, ABT, SVC, SYS) 
 * - Puts the processor in SYSTEM mode and enables IRQ and FIQ 
 * - Calls the C function main() 
 *  
 * The C file /arch/arm/arm.c contains the default exception handlers. These 
 * handlers are defined as "weak" so that they can be redefined.
 *  
 * @par Other resources:
 * - <a href="http://www.atmel.com/dyn/products/app_notes.asp?family_id=605">AT91 Assembler Code Startup Sequence for C Code Applications Software</a> 
 *  
 * @par Example (excerpt): /arch/arm/arm_crt0.S 
 * @dontinclude arch/arm/arm_crt0.S 
 * @skip .section 
 * @until .end 
 *  
 * <hr>
 * @section ARM_AT91_LD Linker scripts 
 *  
 * Linker scripts defines the address and size of memory sections. It also 
 * dictates where each section should be placed in memory and defines symbols 
 * to mark specific memory locations.
 *   
 * @par Example (excerpt): /arch/arm/AT91/boards/linker_scripts/at91sam7s256-rom.lds
 * @dontinclude at91sam7s256-rom.lds 
 * @skip OUTPUT_FORMAT 
 * @until .stab 
 *    
 * <hr>
 * @section ARM_AT91_MAKEFILE Makefile 
 *  
 * A Makefile template has been included that is based on the WinARM and WinAVR 
 * Makefile template. To use it, make a copy to your project directory (renamed 
 * to "Makefile") and edit to add the project files.
 *  
 * File: /arch/ARM/Makefile.Template 
 *  
 * It has the following features: 
 * - Allows a debug or release build (make CFG=debug | make CFG=release) 
 * - Allows an ARM only build, or mixed ARM/Thumb (USE_THUMB_MODE = YES | NO) 
 * - Allows specification of the MCU (e.g. MCU = arm7tdmi) 
 * - Generates various output files: 
 *      - ELF File that can be used for programming and debugging (*.elf) 
 *      - Intel HEX File that can be used for programming (*.hex)
 *      - Binary file that can be used for programming (*.bin)
 *      - Extended assembly listing file that can be used to verify that code has been correctly generated (*.lss)
 *      - Symbol file that can be used to verify the location (address) of functions and variables (*.sym) 
 * - Produces human readable output; see below
 * 
 * @par Build example (/arch/arm/AT91/examples/led_blink):
 * @include arm_at91_ex_make.txt 
 *  
 * <hr>
 * @section ARM_AT91_LSS Extended assembly listing file 
 *  
 * It is advised that the generated extended assembly listing file must always 
 * be inspected to verify that the code has been correctly generated.
 *  
 * @par Example: 
 * @include /arch/arm/AT91/tutorials/03_C_board_init/C_board_init.lss 
 *  
 * <hr>
 * @section ARM_AT91_NEWLIB The Red Hat newlib C Library
 *  
 * Most GCC compilers targeted for ARM, including 
 * <A href="www.yagarto.de">Yagarto</a> is packaged with Newlib as the standard 
 * C library (libc.a and libm.a)
 *  
 * The C library depends on a handful of subroutine calls for operating system 
 * services. On a "bare board" system, without an operating system, 
 * do-nothing stubs (or subroutines with minimal functionality) must be 
 * provided to allow programs to link with the subroutines in libc.a
 *  
 * Documents: 
 * - <a href="http://www.sourceware.org/newlib/libc.html#Syscalls">The Red Hat newlib C Library - 13 System Calls"</a>
 * - <a href="http://www.embedded.com/story/OEG20011220S0058">Embedding with GNU: Newlib</a> 
 * - <a href="http://embedded.com/story/OEG20020103S0073">Embedding GNU: Newlib, Part 2</a> 
 *  
 * The <a href="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4343">AT91 Library Software Package 1.5</a> 
 * makes provision or provides alternatives with:
 * - /atmel_at91lib/utility/retarget.c
 * - /atmel_at91lib/utility/stdio.c
 * - /atmel_at91lib/utility/string.c
 *   
 * <hr>
 * @section ARM_AT91_JTAG JTAG Programming and debugging with OpenOCD 
 *  
 * TBD 
 * 
 */

